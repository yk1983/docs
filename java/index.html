<!DOCTYPE html>
<html lang="ko">
<head>
	<title>커피와 개발자 :: CoderDocsJava</title>
    
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="스터디 교육 자료">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">    
    <link rel="shortcut icon" href="favicon.ico"> 
    
    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
    
    <!-- FontAwesome JS-->
    <script defer src="../assets/fontawesome/js/all.min.js"></script>
    
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="../assets/plugins/simplelightbox/simple-lightbox.min.css">

    <!-- Theme CSS -->  
    <link id="theme-style" rel="stylesheet" href="../assets/css/theme.css">

</head> 

<body class="docs-page">    
    <header class="header fixed-top">	    
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
					<button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none" type="button">
	                    <span></span>
	                    <span></span>
	                    <span></span>
	                </button>
	                <div class="site-logo"><a class="navbar-brand" href="../"><img class="logo-icon me-2" src="../assets/images/coderdocs-logo.svg" alt="logo"><span class="logo-text">Coder<span class="text-alt">Docs</span></span></a></div>
                </div><!--//docs-logo-wrapper-->
	            <div class="docs-top-utilities d-flex justify-content-end align-items-center">
	                <div class="top-search-box d-none d-lg-flex">
		                <form class="search-form">
				            <input type="text" placeholder="Search the docs..." name="search" class="form-control search-input">
				            <button type="submit" class="btn search-btn" value="Search"><i class="fas fa-search"></i></button>
				        </form>
	                </div>
	
					<ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
						<li class="list-inline-item"><a href="#"><i class="fab fa-github fa-fw"></i></a></li>
			            <li class="list-inline-item"><a href="#"><i class="fab fa-twitter fa-fw"></i></a></li>
		                <li class="list-inline-item"><a href="#"><i class="fab fa-slack fa-fw"></i></a></li>
		                <li class="list-inline-item"><a href="#"><i class="fab fa-product-hunt fa-fw"></i></a></li>
		            </ul><!--//social-list-->
		            <a href="https://themes.3rdwavemedia.com/bootstrap-templates/startup/coderdocs-free-bootstrap-5-documentation-template-for-software-projects/" class="btn btn-primary d-none d-lg-flex">Download</a>
	            </div><!--//docs-top-utilities-->
            </div><!--//container-->
        </div><!--//branding-->
    </header><!--//header-->
    
    
    <div class="docs-wrapper">
	    <div id="docs-sidebar" class="docs-sidebar">
		    <div class="top-search-box d-lg-none p-3">
                <form class="search-form">
		            <input type="text" placeholder="Search the docs..." name="search" class="form-control search-input">
		            <button type="submit" class="btn search-btn" value="Search"><i class="fas fa-search"></i></button>
		        </form>
            </div>
		    <nav id="docs-nav" class="docs-nav navbar">
			    <ul class="section-items list-unstyled nav flex-column pb-3">
				    <li class="nav-item section-title"><a class="nav-link scrollto" href="#section-1"><span class="theme-icon-holder me-2"><i class="fas fa-map-signs"></i></span>소개(Introduction)</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-1-1">자바의 특징</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-1-2">JVM</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-1-3">JDK와 JRE</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-2"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>변수(Variable)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-2-1">변수의 선언과 초기화</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-2-2">변수의 명명규칙</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-2-3">상수와 리터럴</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-3"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>자료형(Data Type)</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-1">기본형(primitive type)</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-2">논리형(boolean)</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-3">문자형(char)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-3-4">정수형(byte,short,int,long)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-3-5">실수형(float,double)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-3-6">형변환(casting)</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-4"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>연산자(Operator)</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-1">산술연산자</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-2">대입연산자</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-4-3">증감연산자</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-4-4">비교연산자</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-4-5">논리연산자</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-4-6">비트연산자</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-4-7">기타연산자</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-5"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>제어문</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-1">조건문(if,switch)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-5-2">반복문(for,while,do-while)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-5-3">기타제어문</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-6"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>배열(Array)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-6-1">배열</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-6-2">String 배열</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-3">다차원 배열</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-7"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>객체지향 프로그래밍 I</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-7-1">객체지향언어</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-7-2">클래스와 객체</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-7-3">변수와 메서드</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-7-4">오버로딩(overloading)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-7-5">생성자(constructor)</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-8"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>객체지향 프로그래밍 II</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-8-1">상속(inheritance)</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-8-2">오버라이딩(overriding)</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-8-3">package와 import</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-8-4">제어자(modifier)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-8-5">다형성(polymorphism)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-8-6">추상클래스(abstract class)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-8-7">인터페이스(interface)</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-9"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>예외처리(Exception)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-9-1">예외처리</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-9-2">try-catch</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-9-3">finally블럭</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-9-4">예외 되던지기</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-9-5">사용자정의 예외</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-10"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>java.lang패키지</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-10-1">Object클래스</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-10-2">String클래스</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-10-3">StringBuffer클래스</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-10-4">Math클래스</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-10-5">wrapper클래스</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-11"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>내부 클래스</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-11-1">내부 클래스</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-11-2">익명 클래스</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-12"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>컬렉션 프레임웍</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-12-1">컬렉션 프레임웍</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-12-2">유용한 클래스</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-13"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>쓰레드(thread)</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-14"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>입출력(I/O)</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-14-1">입출력</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-14-2">바이트기반 스트림</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-14-3">바이트기반의 보조스트림</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-14-4">문자기반 스트림</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-14-5">문자기반의 보조스트림</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-14-6">File</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-14-7">직렬화(Serialization)</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-15"><span class="theme-icon-holder me-2"><i class="fas fa-lightbulb"></i></span>FAQs</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-15-1">용어정리</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-15-2">질문</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-15-3">Tip</a></li>
			    </ul>

		    </nav><!--//docs-nav-->
	    </div><!--//docs-sidebar-->
	    <div class="docs-content">
		    <div class="container">
			    <article class="docs-article" id="section-1">
				    <header class="docs-header">
					    <h1 class="docs-heading">소개 (Introduction) <span class="docs-time">Last updated: 2022-05-12</span></h1>
					    <section class="docs-intro">
							<p>우리가 배울 <strong>자바(Java)</strong>는 <strong>객체 지향적 프로그래밍 언어</strong>입니다.</p>
							<p>
								처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발했지만 현재 웹 애플리케이션 개발에 가장 많이 사용하는 언어 가운데 하나이고, 모바일 기기용 소프트웨어 개발에도 널리 사용하고 있습니다.
								자바의 개발자들은 유닉스 기반의 배경을 가지고 있었기 때문에 문법적인 특성은 파스칼이 아닌 C++의 조상인 C 언어와 비슷하지만, 자바를 다른 컴파일언어와 구분 짓는 가장 큰 특징은 <strong>컴파일된 코드가 플랫폼 독립적</strong>이라는 점입니다.
							</p>
							<p>
								자바 컴파일러는 <strong>자바 언어로 작성된 프로그램을 바이트코드라는 특수한 바이너리 형태로 변환</strong>합니다.<br/>
								바이트코드를 실행하기 위해서는 <strong>JVM(자바 가상 머신, Java Virtual Machine)</strong>이라는 특수한 가상 머신이 필요한데, 이 가상 머신은 자바 바이트코드를 어느 플랫폼에서나 동일한 형태로 실행시킵니다.
								때문에 <strong>자바로 개발된 프로그램은 CPU나 운영 체제의 종류에 관계없이 JVM을 설치할 수 있는 시스템에서는 어디서나 실행</strong>할 수 있으며, 이 점이 웹 애플리케이션의 특성과 맞아떨어져 폭발적인 인기를 끌게 되었습니다.
							</p>
						</section><!--//docs-intro-->
				    </header>

				    <section class="docs-section" id="item-1-1">
						<h2 class="section-heading">자바의 특징</h2>
						<ol>
							<li>운영체제에 독립적이다.</li>
							<li>객체지향 언어이다.</li>
							<li>배우기 쉽다.</li>
							<li>자동으로 메모리가 관리된다. (Garbage Collection)</li>
							<li>네트워크와 분산처리를 지원한다.</li>
							<li>멀티쓰레드를 지원한다.</li>
							<li>동적 로딩(Dynamic Loading)을 지원한다.</li>
						</ol>

						<h5>자바의 단점</h5>
                        <div class="callout-block callout-block-info">
                            <div class="content">
                                <h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
	                                Note
	                            </h4>
                                <p>* 자바의 단점으로는 속도문제가 대표적인데, 바이트코드(byte code)를 하드웨어의 기계어로 바로 변환해주는 신기술이 도입되므로써 JVM의 기능이 향상되어 상당히 개선되었다.</p>
                            </div><!--//content-->
                        </div><!--//callout-block-->

					</section><!--//section-->
					
					<section class="docs-section" id="item-1-2">
						<h2 class="section-heading">JVM</h2>
						<p>
							<strong>JVM<sup>Java Virtual Machine (자바 가상 머신)</sup></strong><br/>
							자바를 실행하기 위한 가상 기계(컴퓨터) 라고 할 수 있다.
							자바는 OS에 종속적이지 않다는 특징을 가지고 있다. OS에 종속받지 않고 실행되기 위해선 OS 위에서 자바를 실행시킬 무언가가 필요하다. 그 무언가가 JVM이다.
							즉, OS에 종속받지 않고 CPU 가 자바를 인식, 실행할 수 있게 하는 가상 컴퓨터이다.
						</p>
					</section><!--//section-->
					
					<section class="docs-section" id="item-1-3">
						<h2 class="section-heading">JDK와 JRE</h2>
						<p>
							<strong>JDK<sup>Java Development Kit (자바 개발 키트)</sup></strong><br/>
							자바를 사용하기 위해 필요한 모든 기능을 갖춘 자바용 SDK (Software Development Kit)이다.
							JDK는 JRE를 포함하고 있다. JRE에 있는 모든 것 뿐만 아니라 컴파일러(javac)와 jdb, javadoc 과 같은 도구도 있다. 즉, JDK는 프로그램을 생성, 실행, 컴파일할 수 있다.
						</p>
						<p>
							<strong>JRE<sup>Java Runtime Environment (자바 런타임 환경)</sup></strong><br/>
							JVM + 자바 클래스 라이브러리(Java Class Library) 등으로 구성되어 있다.
							컴파일 된 자바 프로그램을 실행하는데 필요한 패키지이다.
						</p>
						<p>
							<strong>SDK<sup>Software Development Kit (소프트웨어 개발 키트)</sup></strong><br/>
							하드웨어 플랫폼, 운영체제 또는 프로그래밍 언어 제작사가 제공하는 툴이다. 키트의 요소는 제작사마다 다르다.
							SDK의 대표적인 예로, JDK 등이 있다.
							SDK를 활용하여 애플리케이션을 개발할 수 있다.
						</p>

						<h5>JDK와 JRE의 차이</h5>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* JDK는 자바 프로그램을 실행, 컴파일, 개발용 도구.<br/>
									* JRE, JVM를 모두 포함하는 포괄적이 키트이다.<br/>
									* JRE는 자바 프로그램을 실행할 수 있게 하는 도구이다. JVM을 포함하고 있다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->
					</section><!--//section-->
			    </article>
			    
			    <article class="docs-article" id="section-2">
				    <header class="docs-header">
					    <h1 class="docs-heading">변수 (Variable)</h1>
					    <section class="docs-intro">
						    <p>
								수학에서 변수를 변하는 수라고 정의하지만 프로그래밍 언어에서의 <strong>변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미</strong>합니다.<br/>
								즉, 변수란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하며, 이렇게 저장된 값은 변경될 수 있습니다.
								하나의 변수에는 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라집니다.
							</p>
							<p>
								중요한 프로그래밍 능력 중의 하나가 바로 "값(data)을 잘 다루는 것"입니다. 모든 프로그래밍의 기초 지식이 변수인 만큼 값을 저장하는 공간인 변수를 잘 이해하고 활용하는 것이 중요합니다.<br/>
								수학에서는 변수를 변하는 수라고 정의하지만 프로그래밍언어에서는 변수(variable)란 값을 저장할 수 있는 메모리상의 공간을 의미합니다. 이러한 공간에 저장된 값은 변경될 수 있기 때문에 수학용어의 정의와 상통하는 면도 있습니다.
							</p>
							<h5>변수의 의미</h5>
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
										Note
									</h4>
									<p>
										* 변수(variable) : 단 하나의 값을 저장할 수 있는 메모리 공간
									</p>
								</div><!--//content-->
							</div><!--//callout-block-->
						</section><!--//docs-intro-->
				    </header>
					
					<section class="docs-section" id="item-2-1">
						<h2 class="section-heading">변수의 선언과 초기화</h2>
						<p>변수를 사용하기 위해서는 먼저 변수를 선언해야합니다.</p>

						<h5>Syntax : 변수타입 변수이름;</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int age;  // age 라는 이름의 변수를 선언</code></pre>
						</div><!--//docs-code-block-->
						<p>
							<strong>변수타입</strong>은 <strong>변수에 저장될 값이 어떤 타입 (Type)인지를 지정</strong>하는 것입니다. <strong>변수이름</strong>은 말 그대로 <strong>변수에 부여한 이름</strong>입니다.
							변수는 "값을 저장할 수 있는 메모리 공간"이므로 변수의 이름은 메모리 공간에 이름을 붙여주는 것이라 생각할 수 있습니다. 따라서 같은 이름의 변수가 여러 개 선언되어서는 안됩니다.
							<strong>변수의 선언</strong>이라는 것은 <strong>메모리의 빈 공간에 변수타입에 맞는 크기의 저장공간을 확보</strong>하고, <strong>선언한 변수의 이름을 통해서 사용</strong>될 수 있습니다.
						</p>
						<p>
							메모리는 여러 프로그램이 공유하는 자원입니다. 따라서 전에 다른 프로그램에 의해서 저장된 알 수 없는 값(쓰레기값, garbage value)이 남아 있을 수 있기 때문에 <strong>변수를 선언한 이후 변수를 사용하기 전에 반드시 변수를 초기화(initialization)</strong>를 해주어야 합니다.<br/>
							변수에 값을 저장할 때는 대입 연산자(=)를 사용합니다. 대입 연산자는 오른쪽에 위치한 값을 왼쪽(변수)에 저장한다는 뜻입니다.
						</p>
						<h5>Example:</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int age = 25;  // 변수 age에 25 값을 저장

int a;
int b;
// 또는
int a, b; // 한 줄로 선언

int x = 0;
int y = 0;
// 또는
int x = 0, y = 0; // 한 줄로 선언과 초기화를 동시에 진행</code></pre>
						</div>
						<p>
							변수는 한 줄에 하나씩 선언하는 것이 일반적이지만 <strong>타입이 같은 경우 콤마(,)를 구분자로 여러 변수를 한 줄에 선언</strong>하기도 합니다.
							변수의 종류에 따라서 변수의 초기화를 생략할 수 있는 경우도 있지만 변수는 적절한 값으로 초기화해주는 것이 좋습니다.
						</p>
						<h5>두 개의 변수 age와 year를 선언과 초기화를 진행하고 값을 저장하는 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/199c74b859153085129f2bc0d0bcff3b.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->

						<h5>Result :</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">year = 0
age = 18
year = 2018
age = 19</code></pre>
						</div><!--//docs-code-block-->

						<h5>두 변수의 값 교환하는 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/d8d6d2a1bc8a1c399ea0603e4c3a880e.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : Example 결과</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">x = 10, y = 20
x = 20, y = 10</code></pre>
						</div>
					</section><!--//section-->
					
					<section class="docs-section" id="item-2-2">
						<h2 class="section-heading">변수의 명명규칙</h2>
						<p>자바에서는 변수뿐만 아니라 클래스, 메소드 등의 <strong>이름을 짓는데 반드시 지켜야 하는 공통된 규칙</strong>이 있습니다. 자바에서 이름을 생성할 때에 반드시 지켜야 하는 규칙은 다음과 같습니다.</p>

						<h5>필수 규칙:</h5>
						<ul>
							<li>대소문자를 구별하며 길이에 제한이 없습니다.</li>
							<li>예약어는 변수이름이 될 수 없습니다.</li>
							<li>숫자로 시작해서는 안됩니다.</li>
							<li>숫자로 시작해서는 안됩니다.</li>
						</ul>

						<p>
							이외의 필수적은 규칙은 아니지만 프로그래머들에게 권장하고 가독성을 위해 프로그래머들 사이에서 암묵적인 규칙은 다음과 같습니다.
							또한 이러한 규칙들은 프로젝트마다 다를 수 있습니다.
						</p>

						<h5>프로그래들 사이의 암묵적인 규칙:</h5>
						<ul>
							<li>클래스 이름의 첫 글자는 항상 대문자로 합니다. (변수와 메소드는 첫 글자를 소문자로 합니다.)</li>
							<li>여러 단어를 결합하여 이름을 지어줄 때에는 연결되는 단어의 첫 글짜를 대문자로 합니다.</li>
							<li>상수의 이름은 모두 대문자로 하고 여러 단어가 결합될 때는 언더바(_)로 구분합니다.</li>
							<li>여러 사람이 팀을 이루어 프로젝트를 하는 경우에는 서로간의 미리 규칙(coding convention)을 만들어 프로그램 전체에 적용하는 것이 좋습니다.</li>
						</ul>
					</section><!--//section-->

					<section class="docs-section" id="item-2-3">
						<h2 class="section-heading">상수와 리터럴</h2>
						<p>
							<strong>상수(constant)</strong>는 변수와 마찬가지로 <strong>"값을 저장할 수 있는 공간"</strong>이지만 변수와 달리 <strong>한 번 값을 저장하면 다른 값으로 변경할 수 없습니다.</strong><br/>
							상수를 선언하는 방법은 변수와 동일하고, 변수의 타입 앞에 키워드 <code>final</code>을 붙여주기만 하면 됩니다.
						</p>

						<h5>Syntax : final 변수타입 변수이름;</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">final int PI;  // PI 라는 이름의 상수를 선언</code></pre>
						</div><!--//docs-code-block-->

						<p>상수는 반드시 선언과 동시에 초기화가 되어야 하며, 그 후 부터는 상수의 값을 변경하는 것이 허용되지 않습니다.</p>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">final int MAX_SPEED;        // 에러. 상수는 선언과 동시에 초기화해야합니다.
final int MAX_VALUE = 100;  // 정상. 선언과 동시에 초기화
MAX_VALUE = 200;            // 에러. 상수의 값은 변경될 수 없습니다.</code></pre>
						</div><!--//docs-code-block-->
						<p>상수의 이름은 대문자로 하는 것이 암묵적인 관례이며, 여러 단어로 이루어져있는 경우 '_'로 구분합니다.</p>

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* JDK1.6부터는 상수를 선언과 동시에 초기화 하지 않아도 되며, 사용하기 전에만 초기화하면 되도록 변경되었습니다. 하지만 상수는 한번 선언되어 초기화되면 값을 변경 할 수 없으므로 선언과 동시에 초과하 하는 것이 좋습니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<p>
							83, 3.14, 'A' 와 같은 값들은 상수입니다. 프로그래밍에서는 상수를 값을 한 번 저장하면 변경할 수 없는 저장공간으로 정의하고 있기 때문에 이러한 값들과 구분하기 위해서 상수를 다른 이름으로 정의해야 했습니다. 그래서 상수 대신 리터럴 이라는 용어가 생겼습니다.<br/>
							즉 리터럴이라는 용어는 단지 우리가 기존에 알고 사용하던 상수의 다른 용어일 뿐 어렵지 않습니다.
						</p>

						<h5>정의</h5>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 변수(Variable) : 하나의 겂을 저장하기 위한 공간<br/>
									* 상수(constant) : 값을 한번만 저장할 수 있는 공간<br/>
									* 리터럴(literal) : 상수 값 자체를 의미
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->
					</section><!--//section-->
			    </article><!--//docs-article-->
			    
			    
			    <article class="docs-article" id="section-3">
				    <header class="docs-header">
					    <h1 class="docs-heading">자료형(Data Type)</h1>
					    <section class="docs-intro">
							<div class="docs-code-block">
								<pre class="shadow-lg rounded"><code class="json hljs">Java Data Type
	&#8627 Primitive Type
		&#8627 Boolean Type(boolean)
		&#8627 Numeric Type
			&#8627 Integral Type
				&#8627 Integer Type(byte, short, int, long)
				&#8627 Floating Point Type(float, double)
			&#8627 Character Type(char)
	&#8627 Reference Type
		&#8627 Class Type
		&#8627 Interface Type
		&#8627 Array Type
		&#8627 Enum Type</code></pre>
							</div>
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="item-3-1">
						<h2 class="section-heading">기본형(primitive type)</h2>
						<p>
							자바의 자료형은 크게 기본형<sup>(primitive type)</sup>과 참조형<sup>(referene type)</sup>으로 나뉩니다. 그리고 기본형은 다시 <strong>논리형, 문자형, 정수형, 실수형</strong> 네 가지로 분류할 수 있습니다.
						</p>
					</section><!--//section-->
					
					<section class="docs-section" id="item-3-2">
						<h2 class="section-heading">논리형(boolean)</h2>
						<p>논리형은 <strong>참(true)이나 거짓(false) 중 한 가지 값만을 가질 수 있는 불리언 타입을 의미</strong>합니다. 자바의 기본 타입 중 논리형 타입은 <code>boolean</code> 한 가지 밖에 없으며 기본은 <code>false</code> 입니다.</p>

						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">boolean checked = true;
boolean power = FALSE;    // 에러. 자바에서는 대소문자를 구별되기 때문에 소문자를 사용해야합니다.</code></pre>
						</div><!--//docs-code-block-->

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* <strong>boolean (1 byte)</strong> 데이터의 표현 범위는 <code>true</code> 또는 <code>false</code> 두 가지뿐 입니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->
					</section><!--//section-->
					
					<section class="docs-section" id="item-3-3">
						<h2 class="section-heading">문자형(char)</h2>
						<p>문자형 역시 <code>char</code> 한 가지 자료형 뿐입니다. 자바에서 문자형 데이터란 <strong>작은 정수나 문자 하나를 표현할 수 있는 타입을 의미하며 단 하나의 문자만을 저장</strong>합니다.</p>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">char ch = 'A';         // 문자 'A'를 char 타입의 변수 ch 에 저장합니다.
char ch = 65;          // 문자의 코드를 직접 변수에 저장합니다.
int code = (int) ch;   // ch에 저장된 값을 int타입으로 변환하여 저장합니다. (문자의 유니코드를 알 수 있습니다.)</code></pre>
						</div><!--//docs-code-block-->
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 컴퓨터는 2진수밖에 인식하지 못하므로 문자도 숫자로 표현해야 인식할 수 있습니다. 따라서 어떤 문자를 어떤 숫자에 대응시킬 것인가에 대한 약속이 필요해집니다. 위의 문장은 변수에 문자가 저장되는 것처럼 보이지만 사실은 문자가 아닌 문자의 유니코드(정수)가 저장됩니다. 따라서 문자 'A'는 유니코드 65이므로 변수 ch에는 65가 저장됩니다.<br/>
									* C언어와 C++에서는 아스키코드(ASCII)를 사용하여 문자를 표현합니다. 아스키코드(ASCII)는 영문 대소문자를 사용하는 7비트의 문자 인코딩 방식입니다. 아스키코드는 문자 하나를 7비트로 표현하므로, 총 128개의 문자를 표현할 수 있습니다. 하지만 자바에서는 유니코드(unicode)를 사용하여 문자를 표현합니다. 아스키코드는 영문자와 숫자밖에 표현 못 하지만, 유니코드는 각 나라의 모든 언어를 표현할 수 있습니다. 유니코드는 문자 하나를 16비트로 표현하므로, 총 65,536개의 문자를 표현할 수 있습니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->
					</section><!--//section-->

					<section class="docs-section" id="item-3-4">
						<h2 class="section-heading">정수형(byte,short,int,long)</h2>
						<p>자바에서 정수란 <strong>부호를 가지고 있으며, 소수 부분이 없는 수</strong>를 의미합니다. 기본 타입 중 정수를 나타내는 타입은 <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>을 제공하고 있습니다.</p>

						<div class="table-responsive my-4">
							<table class="table table-bordered table-dark">
								<thead>
									<tr>
										<th scope="col">#</th>
										<th scope="col">타입</th>
										<th scope="col">크기</th>
										<th scope="col">데이터의 표현 범위</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<th scope="row">1</th>
										<td>byte</td>
										<td>1 byte</td>
										<td>-128 ~ 127 (-2 7 ~ 2 7 - 1)</td>
									</tr>
									<tr>
										<th scope="row">2</th>
										<td>short</td>
										<td>2 byte</td>
										<td>-32,768 ~ 32,767 (-2 15 ~ 2 15 - 1)</td>
									</tr>
									<tr>
										<th scope="row">3</th>
										<td>int</td>
										<td>4 byte</td>
										<td>-2,147,483,648 ~ 2,147,483,647 (-2 31 ~ 2 31 - 1)</td>
									</tr>
									<tr>
										<th scope="row">3</th>
										<td>long</td>
										<td>8 byte</td>
										<td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (-2 63 ~ 2 63 - 1)</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
						<p>정수형 데이터의 타입을 결정할 때에는 반드시 자신이 사용하고자 하는 데이터의 최대 크기를 고려해야 합니다. 해당 타입이 표현할 수 있는 범위를 벗어난 데이터를 저장하면, <u>오버플로우(overflow)가 발생해 전혀 다른 값이 저장</u>될 수 있기 때문입니다.</p>
						<h5>오버플로우나 언더플로우가 발생하면 결과에 어떠한 영향을 주는지를 보여주는 Example :</h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/92681f82f2e126373a5986480c9d6bdb.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->

						<h5>Result :</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">-128
127</code></pre>
						</div><!--//docs-code-block-->

						<h5>오버플로우<sup>(overflow)</sup>와 언더플로우<sup>(underflow)</sup></h5>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 오버플로우(overflow)란 해당 타입이 표현할 수 있는 최대 범위보다 큰 수를 저장할 때 발생하는 현상을 가리킵니다. 오버플로우가 발생하면 최상위 비트(MSB)를 벗어난 데이터가 인접 비트를 덮어쓰므로, 잘못된 결과를 얻을 수 있습니다.<br/>
									* 언더플로우(underflow)란 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생하는 현상을 가리킵니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

					</section><!--//section-->

					<section class="docs-section" id="item-3-5">
						<h2 class="section-heading">실수형(float,double)</h2>
						<p>자바에서 실수란 <strong>소수부나 지수부가 있는 수</strong>를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가집니다. 자바의 기본 타입 중 실수를 나타내는 타입은 <code>float</code>, <code>double</code>의 두 가지 타입이 있습니다.</p>

						<div class="table-responsive my-4">
							<table class="table table-bordered table-dark">
								<thead>
								<tr>
									<th scope="col">#</th>
									<th scope="col">타입</th>
									<th scope="col">크기</th>
									<th scope="col">데이터의 표현 범위</th>
									<th scope="col">리터럴 접미사</th>
								</tr>
								</thead>
								<tbody>
								<tr>
									<th scope="row">1</th>
									<td>float</td>
									<td>지수 길이 8 bit / 가수 길이 32 bit / 할당 메모리 4 byte</td>
									<td>소수 부분 7자리까지 오차없이 표현 (3.4 X 10 -38) ~ (3.4 X 10 38)</td>
									<td>F 또는 f</td>
								</tr>
								<tr>
									<th scope="row">2</th>
									<td>double</td>
									<td>지수 길이 11 bit / 가수 길이 52 bit / 할당 메모리 8 byte</td>
									<td>소수 부분 15자리까지 오차없이 표현 (1.7 X 10 -308) ~ (1.7 X 10 308)</td>
									<td>D 또는 d (생략가능)</td>
								</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->

						<h5>오버플로우<sup>(overflow)</sup>와 언더플로우<sup>(underflow)</sup></h5>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 과거에는 실수를 표현할 때 float형을 많이 사용했지만, 하드웨어의 발달로 인한 메모리 공간의 증가로 현재에는 double형을 가장 많이 사용합니다. 따라서 <u>실수형 타입 중 기본이 되는 타입은 double형</u>입니다.<br/>
									* 실수형에서도 <u>변수의 값이 표현범위의 최대값을 벗어나면 오버플로우가 발생</u>합니다. 단지 변수의 값이 정수형과 달리 무한대(infinity)가 됩니다. 그리고 정수형에는 없는 언더플로우가 발생하는데 언더플로우는 실수형으로 표현할 수 없는 아주 작은 값, 즉 양의 최소값보다 작은 값이 되면 변수의 값은 0 이 됩니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->
					</section><!--//section-->

					<section class="docs-section" id="item-3-6">
						<h2 class="section-heading">형변환(casting)</h2>
						<p>
							프로그램을 작성하다 보면 같은 타입뿐만 아니라 <strong>서로 다른 타입간의 연산을 수행해야 하는 경우</strong>가 있습니다. 이럴 경우에는 <strong>연산을 수행하기 전에 타입을 일치</strong>시켜야 하는데,
							<strong>변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 형변환(캐스팅, casting)</strong>이라고 합니다.<br/>
							형변환 방법은 간단합니다. 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기만 하면 됩니다. 이 때 사용되는 <strong>괄호()는 캐스트 연산자 또는 형변환 연산자</strong>라고 하며, <strong>형변환을 캐스팅(casting)</strong>이라고 합니다.
						</p>

						<h5>Syntax : (타입) 피연산자</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">double d = 3.14;
// double타입의 변수 d를 int타입으로 형변환
// 이 때 형변환의 결과인 3이 score애 저장
int score = (int) d;</code></pre>
						</div><!--//docs-code-block-->

						<br/>
						<h5>형변환(캐스팅, casting) Example :</h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/e081bd0a1437517f1da30ea2bf7007ae.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->

						<h5>Result :</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">score = 3
d = 3.14  // 형변환 후에도 피연산자에는 아무런 영향이 없습니다.</code></pre>
						</div><!--//docs-code-block-->

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>기본형 타입에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능합니다. 그리고 기본형과 참조형간의 형변환은 불가능합니다.</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>정수형 간의 형변환</h3>
						<p></p>
						<h5>정수형 간의 형변환에서 큰 타입에서 작은 타입으로의 변환 Example :</h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/5edb306f99b8a38073e015f585fd802a.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->

						<h5>Result :</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">[int -> byte] i=10 -> b=10
[int -> byte] i=300 -> b=44
[byte -> int] b=10 -> i=10
[byte -> int] b=-2 -> i=-2
i = 11111111111111111111111111111110</code></pre>
						</div><!--//docs-code-block-->

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>int타입(4byte)의 값을 byte타입(1byte)으로 변환하는 경우 값의 손실이 발생합니다.</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>실수형 간의 형변환</h3>
						<p></p>
						<h5>실수형 간의 형변환에서 큰 타입에서 작은 타입으로의 변환 Example :</h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/4b2ffcbbdcfefa0d8cc6c3691a441c39.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->

						<h5>Result :</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">f = 9.123456954956055000
d = 9.123456700000000000
d2 = 9.123456954956055000</code></pre>
						</div><!--//docs-code-block-->

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 변환하는 경우, 빈 공간을 0으로 채웁니다.</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>정수형과 실수형 간의 형변환</h3>
						<p>
							정수형과 실수형은 저장형식이 완전히 다르기 때문에 정수형간의 변환처럼 간단히 값을 채우고 자르는 식으로는 할 수 없습니다.<br/>
						</p>

						<h5>정수형과 실수형 간의 형변환 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/5dd1c9d867c942b47360e725bb15736b.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->

						<h5>Result :</h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">i = 91234567
f = 91234568.000000, i2 = 91234568
d = 91234567.000000, i3 = 91234567
(int) 1.666000 = 1</code></pre>
						</div><!--//docs-code-block-->

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									<strong class="me-1">정수형을 실수형으로 변환 : </strong>
									정수는 소수점이하의 값이 없으므로 비교적 변환이 간단합니다. 실수형은 정수형보다 휠씬 큰 저장범위를 갖고 있기 때문에, 정수형을 실수형으로 변환하는 것은 무리가 없습니다.<br/>
									<strong class="me-1">실수형을 정수형으로 변환 : </strong>
									실수형을 정수형으로 변환하면, 실수형의 수수점이하 값은 버려집니다. 정수형의 표현 형식으로 소수점 이하의 값은 표현할 수 없기 때문입니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>자동 형변환</h3>
						<p>
							서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는 것이 원칙입니다. 하지만, 경우에 따라 편의상의 이유로 형변환을 생략할 수 있습니다.
							그렇다고 형변환이 이루어지지 않는 것은 아니며, 컴파일러가 생략된 형변환을 자동적으로 추가합니다.
						</p>

						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">float f = 1234;  // 형변환의 생략. float f = (float) 1234;</code></pre>
						</div>
						<p>그러나 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생합니다.</p>

						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">byte b = 1000;  // Error. byte의 범위 (-125 ~ 127)를 넘는 값을 저장.</code></pre>
						</div>
						<p>그러나 다음과 같이 명시적으로 형변환을 해줬을 경우, 형변환이 프로그래머의 실수가 아닌 의도적인 것으로 간주하여 컴파일러는 에러를 발생하지 않습니다.</p>

						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">char ch = (char) 1000;  // OK. 명시적 형변환.</code></pre>
						</div>
						<p>
							또 다른 예로 다음과 같은 계산식에서 자주 형변환이 생략됩니다. 서로 다른 두 타입의 연산에서는 먼저 타입을 일치시킨 다음에 연산을 수행해야 하므로, 연산과정에서 형변환이 자동적으로 이루어집니다.<br/>
							서로 다른 두 타입간의 덧셈에서는 두 타입 중 표현볌위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에 연산을 수행합니다. 그렇게 함으로써 값손실의 위험이 더 적어서 올바른 결과를 얻을 확율이 높기 때문입니다.
						</p>

						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int i = 3;
double d = 1.0 + i;              //  double d = 1.0 + (double) i; 에서 형변환이 생략
// double d = 1.0 + (double) i;
// double d = 1.0 + (double) 3;  // i의 값은 3
// double d = 1.0 + 3.0          // 3을 double타입으로 형변환
// double d = 4.0                // double = double + double</code></pre>
						</div>
						<p>
							연산과정에서 자동적으로 발생하는 형변환을 <strong>산술변환</strong>이라고 합니다.
							이러한 자동 형변환에는 규칙이 있습니다. 컴파일러는 <strong>기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환</strong>합니다.
						</p>

						<h5>기본형의 자동 형변환이 가능한 방향 : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">(byte) &#8594 (short) &#8594 (int) &#8594 (long) &#8594 (float) &#8594 (double)
          (char) &#8599</code></pre>
						</div>
					</section><!--//section-->
			    </article><!--//docs-article-->
			    
			    <article class="docs-article" id="section-4">
				    <header class="docs-header">
					    <h1 class="docs-heading">연산자(Operator)</h1>
					    <section class="docs-intro">
						    <p>
								자바에서는 여러 종류의 연산을 수행하기 위한 다양한 연산자(operator)를 제공하고 있습니다.
							</p>
							<h5>자바에서 제공하는 대표적인 연산자 : </h5>
							<ul>
								<li>산술 연산자(arithmetic operator)</li>
								<li>대입 연산자(assignment operator)</li>
								<li>증감 연산자(increment and decrement operators)</li>
								<li>비교 연산자(comparison operator)</li>
								<li>논리 연산자(logical operator)</li>
								<li>비트 연산자(bitwise operator)</li>
								<li>삼항 연산자(ternary operator)</li>
								<li>instanceof 연산자</li>
							</ul>
						</section><!--//docs-intro-->
				    </header>
					<section class="docs-section" id="item-4-1">
						<h2 class="section-heading">산술연산자(arithmetic operator)</h2>
						<p>
							산술 연산자는 <strong>사칙연산을 다루는 연산자</strong>로, 가장 기본적이면서도 가장 많이 사용되는 연산자 중 하나입니다.
							산술 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.
						</p>
						<h5>산술연산자 : </h5>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">연산자</th>
										<th scope="col">설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>+</td>
										<td>왼쪽의 피연산자에 오른쪽의 피연산자를 더함.</td>
									</tr>
									<tr>
										<td>-</td>
										<td>왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌.</td>
									</tr>
									<tr>
										<td>*</td>
										<td>왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.</td>
									</tr>
									<tr>
										<td>/</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자로 나눔.</td>
									</tr>
									<tr>
										<td>%</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함.</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->
					
					<section class="docs-section" id="item-4-2">
						<h2 class="section-heading">대입 연산자(assignment operator)</h2>
						<p>
							대입 연산자는 <strong>변수에 값을 대입할 때 사용하는 이항 연산자</strong>이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽입니다. 또한, 자바에서는 대입 연산자와 다른 연산자를 결합하여 만든 다양한 복합 대입 연산자를 제공합니다.
						</p>
						<h5>대입연산자 : </h5>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">연산자</th>
										<th scope="col">설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>=</td>
										<td>왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.</td>
									</tr>
									<tr>
										<td>+=</td>
										<td>왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>-=</td>
										<td>왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>*=</td>
										<td>왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>/=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>%=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>&=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자와 비트 AND 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>|=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자와 비트 OR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>^=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자와 비트 XOR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td><<=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자만큼 왼쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>>>=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호를 유지하며 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
									<tr>
										<td>>>>=</td>
										<td>왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호에 상관없이 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->
					
					<section class="docs-section" id="item-4-3">
						<h2 class="section-heading">증감 연산자(increment and decrement operators)</h2>
						<p>
							증감 연산자는 <strong>피연산자를 1씩 증가 혹은 감소시킬 때 사용하는 연산자</strong>입니다. 이 연산자는 피연산자가 단 하나뿐인 <strong>단항 연산자</strong>입니다.<br/>
							증감 연산자는 해당 연산자가 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서 및 결과가 달라집니다.
						</p>
						<h5>증감연산자 : </h5>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">연산자</th>
										<th scope="col">설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>++x</td>
										<td>먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함.</td>
									</tr>
									<tr>
										<td>x++</td>
										<td>먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴.</td>
									</tr>
									<tr>
										<td>--x</td>
										<td>먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함.</td>
									</tr>
									<tr>
										<td>x--</td>
										<td>먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴.</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->

					<section class="docs-section" id="item-4-4">
						<h2 class="section-heading">비교 연산자(relational operator)</h2>
						<p>
							비교 연산자는 피연산자 사이의 <strong>상대적인 크기를 판단하는 연산자</strong>입니다.<br/>
							비교 연산자는 왼쪽의 피연산자와 오른쪽의 피연산자를 비교하여, <strong>어느 쪽이 더 큰지, 작은지, 또는 서로 같은지를 판단</strong>합니다.<br/>
							비교 연산자는 모두 두 개의 피연산자를 가지는 <strong>이항 연산자</strong>이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.
						</p>
						<h5>비교연산자 : </h5>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">연산자</th>
										<th scope="col">설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>==</td>
										<td>왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환함.</td>
									</tr>
									<tr>
										<td>!=</td>
										<td>왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함.</td>
									</tr>
									<tr>
										<td>></td>
										<td>왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 참을 반환함.</td>
									</tr>
									<tr>
										<td>>=</td>
										<td>왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 참을 반환함.</td>
									</tr>
									<tr>
										<td><</td>
										<td>왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 참을 반환함.</td>
									</tr>
									<tr>
										<td><=</td>
										<td>왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 참을 반환함.</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-info-circle"></i>
								</span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 아스키코드(ASCII)는 영문 대소문자를 사용하는 7비트의 문자 인코딩 방식입니다. 아스키코드는 문자를 7비트로 표현하므로, 총 128개의 문자를 표현할 수 있습니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->
					</section><!--//section-->

					<section class="docs-section" id="item-4-5">
						<h2 class="section-heading">논리 연산자(logical operator)</h2>
						<p>
							논리 연산자는 주어진 <strong>논리식을 판단</strong>하여, 참(<code>true</code>)과 거짓(<code>false</code>)을 결정하는 연산자입니다.
							<code>AND</code> 연산과 <code>OR</code> 연산은 두 개의 피연산자를 가지는 <strong>이항 연산자</strong>이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.
							<code>NOT</code> 연산자는 피연산자가 단 하나뿐인 <strong>단항 연산자</strong>이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽입니다.
						</p>
						<h5>논리연산자 : </h5>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">연산자</th>
										<th scope="col">설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>&&</td>
										<td>논리식이 모두 참이면 참을 반환함. (논리 AND 연산)</td>
									</tr>
									<tr>
										<td>||</td>
										<td>논리식 중에서 하나라도 참이면 참을 반환함. (논리 OR 연산)</td>
									</tr>
									<tr>
										<td>!</td>
										<td>논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (논리 NOT 연산)</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->

						<h5>논리 연산자의 모든 동작의 결과를 보여주는 진리표(truth table) : </h5>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">A</th>
										<th scope="col">B</th>
										<th scope="col">A && B</th>
										<th scope="col">A || B</th>
										<th scope="col">!A</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>true</td>
										<td>true</td>
										<td>true</td>
										<td>true</td>
										<td>true</td>
									</tr>
									<tr>
										<td>true</td>
										<td>false</td>
										<td>false</td>
										<td>true</td>
										<td>false</td>
									</tr>
									<tr>
										<td>false</td>
										<td>true</td>
										<td>false</td>
										<td>true</td>
										<td>true</td>
									</tr>
									<tr>
										<td>false</td>
										<td>false</td>
										<td>false</td>
										<td>false</td>
										<td>true</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->

					<section class="docs-section" id="item-4-6">
						<h2 class="section-heading">비트 연산자(bitwise operator)</h2>
						<p>비트 연산자는 논리 연산자와 비슷하지만, <strong>비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자</strong>입니다. 또한, 비트 단위로 왼쪽이나 오른쪽으로 전체 비트를 이동하거나, 1의 보수를 만들 때도 사용됩니다.</p>

						<h5>비트연산자 : </h5>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">연산자</th>
										<th scope="col">설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>&</td>
										<td>대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)</td>
									</tr>
									<tr>
										<td>|</td>
										<td>대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)</td>
									</tr>
									<tr>
										<td>^</td>
										<td>대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)</td>
									</tr>
									<tr>
										<td>~</td>
										<td>비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산, 1의 보수)</td>
									</tr>
									<tr>
										<td><<</td>
										<td>명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산)</td>
									</tr>
									<tr>
										<td>>></td>
										<td>부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산)</td>
									</tr>
									<tr>
										<td>>>></td>
										<td>지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨.</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->

					<section class="docs-section" id="item-4-7">
						<h2 class="section-heading">기타연산자</h2>
						<br/>
						<h3>삼항연산자</h3>
						<p>
							<strong>삼항 연산자(ternary operator)</strong>는 자바에서 유일하게 피연산자를 세 개나 가지는 <strong>조건 연산자</strong>입니다.<br/>
							<strong>삼항 연산자</strong>는 <strong>조건식이 참(true)이면 (?)의 다음 반환값1을 실행하고 거짓(false)이면 (:)의 다음 반환값2를 실행</strong>합니다.
						</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">(조건문) ? 반환값1 : 반환값2</code></pre>
						</div>

						<br/>
						<h3>instanceof 연산자</h3>
						<p>instanceof 연산자는 <strong>참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환</strong>해 줍니다. 즉, 해당 <strong>객체가 어떤 클래스나 인터페이스로부터 생성되었는지를 판별해 주는 역할</strong>을 합니다.</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">인스턴스이름 instanceof 클래스또는인터페이스이름</code></pre>
						</div>

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-info-circle"></i>
								</span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* instanceof 연산자는 왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 true를 반환하고, 그렇지 않으면 false를 반환합니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->
					</section><!--//section-->
			    </article><!--//docs-article-->
			    
			    <article class="docs-article" id="section-5">
				    <header class="docs-header">
					    <h1 class="docs-heading">제어문(control flow statements)</h1>
					    <section class="docs-intro">
						    <p>
								프로그램 코드의 실행흐름은 기본적으로 순차적으로 진행되지만 때로는 조건에 따라 문장을 실행시킬지 여부를 정하고 같은 문장을을 반복 수행해야 할 때, <strong>프로그램의 흐름(flow)을 바꾸는 역활</strong>을 해주어야 합니다.
								이러한 역활을 하는 문장들을 <strong>제어문(control statement)</strong>라고 합니다.
							</p>
						</section><!--//docs-intro-->
				    </header>
					<section class="docs-section" id="item-5-1">
						<h2 class="section-heading">조건문(if,switch)</h2>
						<p>
							<strong>조건문<sup>(conditional statements)</sup></strong>은 <strong>조건식의 연산결과에 따라서</strong> 다른 문장이 수행되거나, 특정 조건에만 실행 또는 실행을 건너뛰게하는 등 <strong>실행할 문장이 달라져서 프로그램의 실행흐름을 변경</strong>할 수 있습니다.<br/>
							조건문에는 <code>if</code>문과 <code>switch</code>문 두 가지가 있으며 주로 if문이 많이 사용됩니다. 처리하고자 하는 경우의 수가 많을 경우 if문보다 switch문이 효율적이지만, switch문은 if문보다 제약이 많습니다.
						</p>
						<h5>자바에서 사용되는 대표적인 조건문의 형태 : </h5>
						<ul>
							<li><strong class="me-1">if 문</strong></li>
							<li><strong class="me-1">if ~ else 문</strong></li>
							<li><strong>if ~ else if 문</strong></li>
							<li><strong>switch 문</strong></li>
							<li><strong>삼항연산자</strong></li>
						</ul>

						<br/>
						<h3>if문</h3>
						<p>
							가장 기본적으로 사용되는 조건문은 if문 입니다.<br/>
							조건문을 뜻으로 정의하자면 <strong>"만일 ~ 한다면"</strong>이라고 생각하면 됩니다.
							<strong>만일(if) 조건식이 참(true)이면 블럭({}) 안의 문장을 수행</strong>하라라는 의미가 됩니다. 조건식은 다음과 같이 <strong>조건을 정의하는 "조건식"과 문장을 실행하는 "블럭"</strong>으로 이루어져 있습니다.
						</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">if (조건식) {
	// 조건식이 참(true)일 때 수행할 문장
}</code></pre>
						</div><!--//docs-code-block-->

						<div class="row my-3">
							<div class="col-md-6 col-12">
								<h5>if문 Example : </h5>
								<div class="docs-code-block">
									<!-- ** Embed github code starts ** -->
									<script src="https://gist.github.com/yk1983/3cb7015a4a01133949d958b674630f4f.js"></script>
									<!-- ** Embed github code ends ** -->
								</div><!--//docs-code-block-->
							</div>
							<div class="col-md-6 col-12">
								<h5>Result : </h5>
								<div class="docs-code-block">
									<pre class="shadow-lg rounded"><code class="json hljs">해당 문자는 영문 소문자입니다.</code></pre>
								</div>

								<h5>if문 순서도 : </h5>
								<div class="docs-code-block">
								<pre class="shadow-lg rounded"><code class="json hljs">       &lt;소문자입니까?&gt;
            &#8595 참(true)          &#8628
["해당 문자는 영문 소문자입니다."]    거짓(false)
            &#8595                  &#8626
          (종료)</code></pre>
								</div>
							</div>
						</div>
						<p>
							<strong>조건식</strong><br/>
							if문에 사용되는 <strong>조건식은 일반적으로 비교연산자와 논리연산자로 구성</strong>됩니다. <strong>조건식을 작성할 때 실수하기 쉬운 것이, 등가비교 연산자(<code>==</code>) 대신 대입연산자(<code>=</code>)를 사용하는 것</strong>입니다.
							자바에서 <strong>조건식의 결과는 반드시 <code>true</code> 또는 <code>false</code>이어야 한다는 것</strong>입니다.<br/>
							<br/>
							<strong>수행블럭</strong><br/>
							괄호{}를 이용해서 여러 문장을 하나의 단위로 묶을 수 있는데, 이것을 블럭(block)이라고 합니다.
							<strong>블럭은 <code>{</code>으로 시작하여 <code>}</code>로 끝</strong>납니다. <code>}</code>다음에 문장의 끝을 의미하는 세미콜론(<code>;</code>)을 붙이지 않는다는 것에 주의하세요.
						</p>

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-info-circle"></i>
								</span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 위의 코드에서 블록에 속한 명령문은 중괄호({})를 기준으로 오른쪽으로 들여쓰기가 되어 있는 것을 볼 수 있습니다. 이처럼 들여쓰기를 통해 코드의 가독성을 높이는 것을 인덴트(indent)라고 하며, 될 수 있으면 모든 코드를 인덴트하는 것이 좋습니다. 보통 들여쓰기 코드는 탭을 사용하는데 탭은 공백 4칸으로 설정하여 사용하는 것이 좋습니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>if ~ else문</h3>
						<p><code>if</code>문과 함께 사용하는 <code>else</code>문은 <strong>if문에 주어진 조건식의 결과가 거짓(false)이면 주어진 명령문을 실행</strong>합니다.</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">if (조건식) {
	// 조건식이 참(true)일 때 수행할 문장
} else {
	// 조건식이 거짓(false)일 때 수행할 문장
}</code></pre>
						</div>
						<div class="row my-3">
							<div class="col-md-6 col-12">
								<h5>if ~ else문 Example : </h5>
								<div class="docs-code-block">
									<!-- ** Embed github code starts ** -->
									<script src="https://gist.github.com/yk1983/e40b6332a1ff84e11dd8bf9474916dfb.js"></script>
									<!-- ** Embed github code ends ** -->
								</div><!--//docs-code-block-->
							</div>
							<div class="col-md-6 col-12">
								<h5>Result : </h5>
								<div class="docs-code-block">
									<pre class="shadow-lg rounded"><code class="json hljs">해당 문자는 영문 소문자가 아닙니다.</code></pre>
								</div>

								<h5>if ~ else문 순서도 : </h5>
								<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">                     &lt;소문자입니까?&gt;
       참(true) &#8595                     &#8595 거짓(false)
["해당 문자는 영문 소문자입니다."]["해당 문자는 영문 소문자가 아닙니다."]
		&#8627       (종료)        &#8626</code></pre>
								</div>
							</div>
						</div>

						<br/>
						<h3>if ~ else if문</h3>
						<p>
							<code>if ~ else if</code>문은 마치 새로운 구문처럼 보이지만, 사실은 두 개의 if ~ else 문이 연달아 나온 것뿐입니다. 이러한 <strong>if ~ else if 문은 조건식을 여러 개 명시</strong>할 수 있으므로 <strong>중첩된 if 문을 좀 더 간결하게 표현</strong>할 수 있습니다.
							<strong>if문의 조건식에 만족하지 않을 때, else if 문의 조건을 판단</strong>>하여 <strong>참이면 블럭({})의 문장을 실행</strong>하고 <strong>이 조건도 거짓이면 else 문을 실행</strong>합니다.
							이때 <strong>else if 문은 여러 번 나와도 상관없지만, if 문과 else 문은 단 한 번</strong>만 나올 수 있습니다.
						</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">if (조건식1) {
	// 조건식1이 참(true)일 때 수행할 문장
} else if (조건식2) {
	// 조건식1이 거짓(false)이고, 조건식2가 참(true)일 때 수행할 문장
} else {
	// 조건식1이 거짓(false)이고, 조건식2도 거짓(false)일 때 수행할 문장
}</code></pre>
						</div>
						<div class="row my-3">
							<div class="col-md-6 col-12">
								<h5>if ~ else if문 Example : </h5>
								<div class="docs-code-block">
									<!-- ** Embed github code starts ** -->
									<script src="https://gist.github.com/yk1983/0fa7b5b30b25c72e848d1a0a642b16b9.js"></script>
									<!-- ** Embed github code ends ** -->
								</div><!--//docs-code-block-->
							</div>
							<div class="col-md-6 col-12">
								<h5>Result : </h5>
								<div class="docs-code-block">
									<pre class="shadow-lg rounded"><code class="json hljs">해당 문자는 영문자가 아닙니다.</code></pre>
								</div>

								<h5>if ~ else if문 순서도 : </h5>
								<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">                         &lt;소문자입니까?&gt;
       참(true) &#8595                         &#8595 거짓(false)
["해당 문자는 영문 소문자입니다."]          &lt;대문자입니까?&gt;
         (종료) &#8626             참(true) &#8595        &#8595 거짓(false)
           ["해당 문자는 영문 소문자가 아닙니다."]  ["해당 문자는 영문자가 아닙니다."]
		               &#8627        (종료)        &#8626</code></pre>
								</div>
							</div>
						</div>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-info-circle"></i>
								</span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* if 문의 블럭 {} : <code>if</code>문, <code>if ~ else</code>문, <code>if ~ else if</code>문에서 <strong>실행될 명령문이 한 줄뿐이라면 괄호{}를 생략하여 코딩할 수 있습니다만, 코드의 가독성을 위해서 생략하지 않는 것</strong>이 좋습니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>중첩된 if 문</h3>
						<p><strong>if문의 블럭 내에 또 다른 if문을 포함</strong>시키는 것이 가능한데 이것을 중첩 if문이라고 부르며 중첩의 횟수에는 제한이 거의 없습니다.</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">if (조건식) {
	// 조건식1이 참(true)일 때 수행할 문장
	if (조건식2) {
		// 조건식1과 조건식2가 모두 참(true)일 때 수행할 문장
	} else {
		// 조건식1이 참(true)이고, 조건식2가 거짓(false)일 때 수행할 문장
	}
} else {
	// 조건식1의 결과가 거짓(false)일 때 수행할 문장
}</code></pre>
						</div>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-info-circle"></i>
								</span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 위와 같이 내부의 if문은 외부의 if문보다 안쪽으로 들여쓰기를 하여 두 if문의 범위가 명확히 구분될 수 있도록 작성해야 합니다. 특히 <strong>중첩 if문에서는 블럭({})을 생략에 조심</strong>해야 합니다.
									외부의 if문과 안쪽의 if문이 서로 엉켜서 <strong>if문과 else블럭의 관계가 의도한 바와 다르게 동작</strong>할 수 있기 때문입니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>switch문</h3>
						<p>
							<code>if</code>문은 조건식의 결과가 참(<code>true</code>)과 거짓(<code>false</code>), 두 가지 밖에 없기 때문에 경우의 수가 많아질수록 <code>else if</code>문를 계속 추가해야하므로 조건식이 많아져서 복잡해지고 여러 개의 조건식을 계산해야하므로 처리시간도 많이 걸립니다.<br/>
							<code>switch</code>문은 <strong>단 하나의 조건식으로 많은 경우의 수를 처리</strong>할 수 있고, <strong>표현도 간결</strong>하므로 알아보기 쉽습니다.
						</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">switch (조건식) {
	case 값1:
		// 조건식의 결과가 값1과 같을 경우 수행될 문장
		// ...
		break;
	case 값2:
		// 조건식의 결과가 값2와 같을 경우 수행될 문장
		break;
	...
	default:
		// 조건식의 결과와 일치하는 case문이 없을 때 수행될 문장
		// ...
}</code></pre>
						</div>
						<h5>switch문의 실행순서 : </h5>
						<ol>
							<li>조건식을 계산합니다.</li>
							<li>조건식의 결과와 일치하는 <code>case</code>문으로 이동합니다.(일치하는 <code>case</code>문이 없으면 <code>default</code>문을 실행합니다.)</li>
							<li>이후의 문장들을 수행합니다.</li>
							<li><code>break</code>문이나 <code>switch</code>문의 끝을 만나면 <code>switch</code>문 전체를 빠져나갑니다.</li>
						</ol>
						<h5>switch문 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/4c2fe96af951fd9b7f1b0fff522055ce.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">해당 문자는 'I'입니다.</code></pre>
						</div>
						<p>
							<code>default</code>절은 위의 예제와 같이 맨 마지막에 위치하는 것이 일반적이지만, <code>case</code>절 사이에 위치해도 상관없습니다. 각 <code>case</code>절 및 <code>default</code>절은 반드시 break 키워드를 포함하고 있어야 합니다.<br/>
							<code>break</code>키워드는 <strong>조건 값에 해당하는 case절이나 default절이 실행된 뒤에 전체 switch문을 빠져나가게 해줍니다.</strong> 만약에 <strong>break 키워드가 없다면, 조건에 해당하는 switch 문의 case 절 이후의 모든 case 절이 전부 실행</strong>될 것입니다.
						</p>
						<h5>switch문의 제약조건 : </h5>
						<ul>
							<li>switch문의 조건식 결과는 정수 또는 문자열(<u>JDK 1.7 이전에는 문자열이 허용되지 않습니다.</u>)이어야 합니다.</li>
							<li>case문의 값은 정수 상수만 가능하며, 중복되지 않아야 합니다.</li>
							<li>break문이 없으면 아래 문장이 계속 실행됩니다.</li>
						</ul>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-info-circle"></i>
								</span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* if문처럼 switch문도 중첩이 가능합니다. 한 가지 주의할 점은 중첩 switch문에서 break문을 잊어버리지 않도록 조심해야 합니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>삼항연산자</h3>
						<p>
							자바에서는 간단한 if ~ else 문은 삼항 연산자를 이용하여 간결하게 표현할 수 있습니다.
							<strong>삼항 연산자</strong>는 <strong>조건식이 참(true)이면 (?)의 다음 반환값1을 실행하고 거짓(false)이면 (:)의 다음 반환값2를 실행</strong>합니다.
						</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">(조건문) ? 반환값1 : 반환값2</code></pre>
						</div>
						<h5>삼항연산자 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/143de01458e5e555e28d0f38fb44ca39.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">두 정수 중 더 큰 수는 7 입니다.</code></pre>
						</div>

					</section><!--//section-->
					
					<section class="docs-section" id="item-5-2">
						<h2 class="section-heading">반복문(for,while,do-while)</h2>
						<p>
							<strong>반복문<sup>(iteration statements)</sup></strong>은 어떤 <strong>작업이 반복적으로 수행</strong>되도록 할 때 사용되며 <strong>프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문</strong>입니다.
							프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나입니다.
						</p>
						<h5>자바에서 사용되는 대표적인 반복문의 형태 : </h5>
						<ul>
							<li><strong>for 문</strong></li>
							<li><strong>Enhanced for 문</strong></li>
							<li><strong>while 문</strong></li>
							<li><strong>do-while 문</strong></li>
						</ul>

						<br/>
						<h3>for 문</h3>
						<p>
							for문은 반복할 횟수를 정확히 알 수 있을 경우 적합합니다. 구조가 복잡하게 보이지만 직관적인 구조라 이해하기 쉽습니다. <code>for</code>문은 <strong>초기화, 조건식, 증감식, 블럭{} 4부분</strong>으로 이루어져있으며 실행의 순서는 다음과 같습니다.
						</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">for (초기식; 조건식; 증감식) {
	// 조건식의 결과가 참인 동안 반복적으로 수행할 문장
}</code></pre>
						</div>
						<ul>
							<li><strong>초기식</strong> : 반복문에 사용될 변수를 초기화하는 부분이며 처음에 한번만 수행됩니다.</li>
							<li><strong>조건식</strong> : 조건식이 참(true)일 경우 반복을 계속하고 거짓(false)이면 반복을 중단합니다.</li>
							<li><strong>증감식</strong> : 반복문을 제어하는 변수의 값을 증가 또는 감소시키는 식입니다.</li>
							<li><strong>블럭{}</strong> : 반복을 하는동안 실행될 문장입니다.</li>
						</ul>
						<p>
							<strong>초기식은 반복문에 사용될 변수를 초기화하는 부분이며 처음 한번만 수행</strong>됩니다. 보통 변수 하나로 for문을 제어하지만, 둘 이상의 변수가 필요한 때는 아래와 같이 콤마(,)를 구분자로 변수를 초기화하면 됩니다. (단, 변수의 타입은 같아야 합니다.)
						</p>
						<h5>초기식 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">for (int i = 1; i < 10; i++) { ... }                // 변수 i의 값을 1로 초기화합니다.
for (int i = 1, j = 0; i < 10; i++) { ... }         // int 타입의 변수 i를 1로 j를 0으로 각각 선언하고 초기화합니다.</code></pre>
						</div>

						<p>
							<strong>조건식의 값이 참(true)이면 반복을 계속하고, 거짓(false)이면 반복을 중단</strong>하고 for문을 벗어납니다. 즉, 조건식이 참(true)인 동안 반복을 계속합니다. 조건식을 잘못 작성하면 블럭({})내의 문장이 한 번도 수행되지 않거나 영원히 반복되는 무한반복에 빠지므로 주의해야 합니다.
						</p>
						<h5>조건식 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">for (int i = 1; i <= 10; i++) { ... }               // 조건식 i가 10보다 작거나 같을 경우 블럭{}안의 문장을 반복</code></pre>
						</div>

						<p>
							<strong>증감식은 반복문을 제어하는 변수의 값을 증가 또는 감소시키는 식</strong>입니다. 매 반복마다 변수의 값이 증감식에 의해서 점진적으로 변하다가 결국 조건식이 거짓이 되어 for문을 벗어나게 됩니다. 증감식도 콤마(,)를 이용해서 두 문장 이상을 하나로 연결해서 쓸 수 있습니다.
						</p>
						<h5>증감식 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">for (int i = 1; i <= 10; i++) { ... }               // i가 1부터 1씩 증가합니다.
for (int i = 1; i <= 10; i--) { ... }               // i가 1부터 1씩 감소합니다.
for (int i = 1; i <= 10; i+=2) { ... }              // i가 1부터 2씩 증가합니다.
for (int i = 1; i <= 10; i*=3) { ... }              // i가 1부터 3배씩 증가합니다.
for (int i = 1, j = 10; i <= 10; i++, j--) { ... }  // i를 1부터 1씩 증가하고 j를 10부터 1씩 감소합니다.</code></pre>
						</div>

						<p>
							<strong>초기식, 조건식, 증감식은 각각 생략이 가능</strong>합니다. 조건식이 생략된 경우 항상 참(true)가 되어 <strong>for문은 무한반복</strong>을 하게됩니다. 이 때 블럭{} 안에 조건식을 넣어 무한반복을 빠져나오게 할 수 있습니다.
						</p>
						<h5>무한반복 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">for (;;) { ... }            // 초기화, 조건식, 증감식 모두 생략이 가능합니다. 조건식은 참(true)이 됩니다.</code></pre>
						</div>

						<br/>
						<h3>중첩된 for문</h3>
						<p>
							for문도 if문과 마찬가지로 <strong>for문안에 또 다른 for문을 포함시키는 것이 가능</strong>합니다. 이러한 중첩 for문은 횟수의 제한이 거의 없습니다.
						</p>
						<h5>구구단 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/2de0417113c8abcd21b08fa851a576c8.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">2 x 1 = 2
2 x 2 = 4
2 x 3 = 6
2 x 4 = 8
2 x 5 = 10
2 x 6 = 12
2 x 7 = 14
2 x 8 = 16
2 x 9 = 18
~ 생략 ~
9 x 1 = 9
9 x 2 = 18
9 x 3 = 27
9 x 4 = 36
9 x 5 = 45
9 x 6 = 54
9 x 7 = 63
9 x 8 = 72
9 x 9 = 81</code></pre>
						</div>

						<br/>
						<h3>향상된 for문</h3>
						<p>
							<strong>JDK 1.5</strong>부터 배열과 컬렉션에 저장된 요소에 접근할 때 <strong>기존보다 편리한 방법으로 처리할 수 있도록 for문의 새로운 문법이 추가</strong>되었습니다.
						</p>
						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">for (타입 변수명 : 배열 또는 컬렉션) {
	// 반복할 문장
}</code></pre>
						</div>
						<ul>
							<li><strong>타입 변수명</strong> : 배열 또는 컬렌셕의 요소 타입의 변수</li>
							<li><strong>배열 또는 컬렉션</strong> : 반복해서 값을 읽을 배열 또는 컬렉션</li>
							<li><strong>블럭{}</strong> : 반복 수행할 문장</li>
						</ul>
						<p>
							변수명의 타입은 배열 또는 컬렉션의 요소의 타입이어야 합니다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장됩니다. 그리고 반복문의 블럭{}내에서는 이 변수를 사용해서 코드를 작성합니다.
						</p>
					</section><!--//section-->
					
					<section class="docs-section" id="item-5-3">
						<h2 class="section-heading">기타제어문</h2>
						<p>
							조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행합니다. 하지만 <code>continue</code>문과 <code>break</code>문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와줍니다.
						</p>

						<br/>
						<h3>break문</h3>
						<p>
							<code>break</code>문은 루프 내에서 사용하여 해당 <strong>반복문을 완전히 종료</strong>시킨 뒤, <strong>반복문 바로 다음에 위치한 명령문을 실행</strong>합니다.
							즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용합니다.
						</p>
						<h5>break문 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/3468128bfeca04a8ab942d5fee4887c6.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">105
14</code></pre>
						</div>

						<br/>
						<h3>이름을 가지는 반복문(break with label)</h3>
						<p>
							일반적인 break문은 단 하나의 반복문만을 빠져나가게 해줍니다.
							따라서 여러 반복문이 중첩된 상황에서 한 번에 모든 반복문을 빠져나가거나, 특정 반복문까지만 빠져나가고 싶을 때는 다른 방법을 사용해야 합니다.<br/>
							이때 사용할 수 있는 방법이 바로 반복문에 이름(label)을 설정하는 것입니다.<br/>
							가장 바깥쪽 반복문이나 빠져나가고 싶은 특정 반복문에 이름을 설정한 후, break키워드 다음에 해당 이름을 명시하면 됩니다.
							그러면 해당 break키워드는 현재 반복문이 아닌 해당 이름의 반복문 바로 다음으로 프로그램의 실행을 옮겨줍니다.
							단, 이때 이름(label)은 가리키고자 하는 반복문의 키워드 바로 앞에 위치해야 합니다.<br/>
							이름과 반복문의 키워드 사이에 명령문이 존재하면, 자바 컴파일러는 오류를 발생시킵니다.
						</p>
						<h5>break label문 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/af5d4b2b8b18aa2c272a522b41eb1edf.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">2 x 1 = 2
2 x 2 = 4
2 x 3 = 6
2 x 4 = 8
2 x 5 = 10
2 x 6 = 12
2 x 7 = 14
2 x 8 = 16
2 x 9 = 18</code></pre>
						</div>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-info-circle"></i>
								</span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* C언어나 C++과는 달리 자바에는 goto 문이 없습니다. 따라서 이렇게 반복문을 가리키는 이름(label)은 break 문이나 continue 문에만 사용될 수 있습니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>continue문</h3>
						<p>
							continue 문은 루프 내에서 사용하여 <strong>해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단</strong>으로 넘어가게 해줍니다.
							보통 <strong>반복문 내에서 특정 조건에 대한 예외 처리</strong>를 하고자 할 때 자주 사용됩니다.
						</p>
						<h5>continue문 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/ad7f59eea2ebfc3bef92e0f49bb262d7.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">5
7
10
14
15
20
~ 생략 ~
91
95
98
100</code></pre>
						</div>
					</section><!--//section-->
			    </article><!--//docs-article-->
			    
		        <article class="docs-article" id="section-6">
				    <header class="docs-header">
					    <h1 class="docs-heading">배열(Array)</h1>
					    <section class="docs-intro">
						    <p>
								<strong>배열<sup>(Array)</sup></strong>은 <strong>같은 타입의 변수들로 이루어진 유한 집합</strong>으로 정의할 수 있습니다.<br/>
								<strong>배열을 구성하는 각각의 값</strong>을 배열 <strong>요소<sup>(element)</sup></strong>라고 하며, <strong>배열에서의 위치</strong>를 가리키는 숫자를 <strong>인덱스<sup>(index)</sup></strong>라고 합니다.
								자바에서 <strong>인덱스는 언제나 0부터 시작</strong>하며, 0을 포함한 양의 정수만을 가질 수 있습니다.<br/>
								배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조입니다.
								배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있습니다.
								하지만 현실적으로 이해하기가 쉬운 2차원 배열까지가 많이 사용됩니다.
							</p>
						</section><!--//docs-intro-->
				    </header>
					<section class="docs-section" id="item-6-1">
						<h2 class="section-heading">배열</h2>
						<br/>
						<h3>배열의 선언</h3>
						<p>배열을 선언하는 방법은 원하는 <strong>타입의 변수를 선언</strong>하고 변수 또는 타입에 <strong>배열임을 의미하는 대괄호[]</strong>를 붙이면 됩니다. 배열이란 자료형의 종류가 아닌 자료형의 집합을 의미합니다.</p>

						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">타입[] 배열이름;
타입 배열이름[];</code></pre>
						</div>

						<h5>배열의 선언 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[] score;
String[] name;

int score[];
String name[];</code></pre>
						</div>

						<br/>
						<h3>배열의 생성</h3>
						<p>배열을 선언한 다음에는 배열을 생성해야 합니다. 배열을 생성하기 위해서는 다음과 같이 연산자 <code>new</code>와 함께 배열의 타입과 길이를 지정해주어야 합니다.</p>

						<h5>Syntax : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">타입[] 변수이름;
변수이름 = new 타입[길이];</code></pre>
						</div>

						<h5>배열의 선언과 생성 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[] score;                 // 배열을 선언 (배열을 다루기 위한 참조변수 선언)
score = new int[5];          // 배열을 생성 (실제 저장공간을 생성)
// 또는
int[] score = new int[5];    // 배열의 선언과 생성을 동시에</code></pre>
						</div>

						<br/>
						<h3>배열의 길이와 인덱스</h3>
						<p>
							생성된 배열의 각 저장공간을 <strong>배열의 요소(element)</strong>라고 하며, 배열이름[인덱스]의 형식으로 배열의 요소에 접근합니다.<br/>
							<strong>인덱스(index)는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별</strong>하는데 사용됩니다.<br/>
							배열에 값을 저장하고 읽어오는 방법은 변수와 동일하고, <strong>변수이름 대신 배열이름[인덱스]를 사용</strong>한다는 것만 다릅니다.
						</p>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>* 인덱스(index)의 범위는 <strong>0 부터 시작하며 배열길이 -1</strong> 까지입니다.</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<h5>배열 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/2d9103ecb5d5bf9bb61577df5176a4e4.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">score[0]:50
score[1]:60
score[2]:70
score[3]:80
score[4]:90
tmp:170</code></pre>
						</div>

						<h5>배열을 다룰 때 주의할 점 : </h5>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* index의 범위를 벗어난 값을 index로 사용하지 않아야 합니다. 컴파일러는 이러한 실수를 걸러주지 못합니다.
									그래서 <strong>유효하지 않은 범위의 값을 index로 사용</strong>하는 것은 실행 시에 에러 <strong>(ArrayIndexOutOfBoundsException)</strong> 가 발생합니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>배열의 길이</h3>
						<p>
							배열을 생성할 때 괄호[]언애 뱌욜의 길이를 적어줘야 하는데, 배열의 길이는 배열의 요소의 개수, 즉 값을 저장할 수 잇는 공간의 개수를 의미합니다.
						</p>
						<p>
							자바에서는 JVM이 모든 배열의 길이를 별도로 관리하며, <code>배열이름.length</code>를 통해서 배열의 길이에 대한 정보를 얻을 수 있습니다.
							배열은 한번 생성되면 길이를 변경할 수 없으므로, 이미 생성된 배열의 길이는 변하지 않습니다. 따라서 <code>배열이름.length</code>는 상수입니다.
						</p>
						<p>
							위의 예제 (<u>배열 Example</u>)의 for문에서 아래와 같이 배열의 길이(<code>score.length</code>)로 출력을 변경하더라도 결과는 동일합니다.
						</p>

						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">// for문으로 배열의 모든 요소를 출력합니다.
for (var i = 0; i < score.length; i++) {
	System.out.printf("score[%d]:%d%n", i, score[i]);
}</code></pre>
						</div>

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 배열의 길이는 int범위의 양의 정수(0도 포함)입니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>배열의 길이 변경</h3>
						<p>
							배열은 한번 선언되고 나면 길이를 변경할 수 없습니다. 따라서 배열에 저장공간이 부족한 경우에는 다음과 같은 방법으로 변경해주어야 합니다.
						</p>
						<h5>배열의 길이 변경 방법 : </h5>
						<ol>
							<li>더 큰 배열을 새로 생성합니다.</li>
							<li>기존 배열의 내용을 새로운 배열에 복사합니다.</li>
						</ol>

						<br/>
						<h3>배열의 초기화</h3>
						<p>
							배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화 되므로 배열을 사용하기 전에 따로 초기화를 해주지 않아도 되지만, 원하는 값을 저장하려면 각 요소마다 값을 지정해주어야 합니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">// 길이가 5인 int형 배열을 선언합니다.
int[] score = new int[5];

// 각 요소에 직접 값을 저장합니다.
int[0] = 50;
int[1] = 60;
int[2] = 70;
int[3] = 80;
int[4] = 90;</code></pre>
						</div>

						<p>
							초기화하려는 값에 일정한 규칙이 있다면, for문을 이용하면 더 좋습니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">// for문을 이용한 초기화
int[] score = new int[5];
for (var i = 0; i < score.lenght; i++) {
	score[i] = i * 10 + 50;
}</code></pre>
						</div>

						<p>
							for문으로 배열을 초기화하려면, 저장하려는 값에 일정한 규칙이 있어야만 가능하기 때문에 배열을 간단히 초기화 하는 방법도 있습니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">// 배열의 생성과 초기화를 동시에
int score = new int[]{50, 60, 70, 80, 90};</code></pre>
						</div>

						<p>
							new 타입[]를 생략하여 코드를 더 간단히 할 수도 있습니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[] score = new int[] {50, 60, 70, 80, 90};
int[] score = {50, 60, 70, 80, 90};        // OK, new int[]를 생략할 수 있습니다.

int[] score;
score = new int[] {50, 60, 70, 80, 90};    // OK, new int[]를 생략할 수 있습니다.
score = {50, 60, 70, 80, 90};              // Error, new int[]를 생략할 수 없습니다.</code></pre>
						</div>

						<p>
							또 다른 방법으로 매개변수로 int형 배열을 받는 <code>add</code>메서드가 정의 되어있고 이 메서드를 호출해야할 경우 new 타입[]을 생략할 수 없습니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int add(int[] arr) { /* 내용 생략*/ }                 // add 메서드
int score = add(new int[] {50, 60, 70, 80, 90});    // OK
int score = add({50, 60, 70, 80 90});               // Error, new int[]를 생략할 수 없습니다.</code></pre>
						</div>

						<p>
							여기서 알아두어야 할 점은 괄호{} 안에 아무 것도 넣지 않으면, 길이가 0인 배열이 생성된다는 것입니다. 따라서 아래 세 문장은 모두 길이가 0이 생성되는 문장들입니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[] score = new int[0];
int[] score = new int[] {};
int[] score = {};</code></pre>
						</div>

						<br/>
						<h3>배열의 출력</h3>
						<p>
							배열을 초기화할 때 for문을 사용하듯이, 배열에 저장된 값을 확인할 때도 다음과 같이 사용하면 됩니다.
						</p>

						<h5>for문을 사용한 출력 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[] score = {50, 60, 70, 80, 90};

for (var i = 0; i < score.length; i++) {
	System.out.println(score[i]);    // 배열의 요소를 순서대로 하나씩 출력합니다.
}</code></pre>
						</div>

						<p>
							더 간단한 방법은 <strong><code>Arrays.toString(배열이름)</code></strong>메서드를 사용하는 것입니다. 이 메서드는 <strong>배열의 모든 요소를 [첫번째 요소, 두번째 요소, ...]와 같은 형식의 문자열로 만들어서 반환</strong>합니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[] score = {50, 60, 70, 80, 90};
System.out.println(Arrays.toString(score)); // 배열 score의 모든 요소를 출력합니다. [50, 60, 70, 80, 90]이 출력됩니다.</code></pre>
						</div>

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>
									* 배열의 변수 score의 값을 그대로 출력하면 어떻게 될까?<br/>
									score는 참조변수이므로 변수에 저장된 값, 즉 <code>타입@주소</code>가 출력 됩니다.
									예외적으로 char배열은 println 메서드로 출력하면 각 요소가 구분자없이 그대로 출력되는데, 이것은 println 메서드가 char배열일 때만 이렇게 동작하도록 작성되었기 때문입니다.
								</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<br/>
						<h3>배열의 복사</h3>
						<p>
							배열은 한번 생성하면 그 길이를 변경할 수 없다고 배웠습니다. 따라서 더 많은 저장공간이 필요하다면 보다 큰 배열을 새로 만들어 이전 배열로부터 내용을 복사해야 합니다.
						</p>

						<h5>배열의 복사 방법 : </h5>
						<ul>
							<li>for문을 이용한 방법</li>
							<li>System.arraycopy()메서드를 이용한 방법</li>
						</ul>

						<h5>배열의 복사 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/222b502e648ee2d13ac01bf639039750.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">[변경 전]
arr.length : 5
arr[0] : 1
arr[1] : 2
arr[2] : 3
arr[3] : 4
arr[4] : 5
[변경 후]
arr.length : 10
arr[0] : 1
arr[1] : 2
arr[2] : 3
arr[3] : 4
arr[4] : 5
arr[5] : 0
arr[6] : 0
arr[7] : 0
arr[8] : 0
arr[9] : 0</code></pre>
						</div>
						<p>
							for문을 이용하여 배열을 복사하는 방법보다는 System클래스의 arraycopy() 메서드를 이용하여 복사하는 방법이 더 간단하고 빠릅니다.
						</p>

						<h5>System.arraycopy()를 이용한 배열의 복사 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/53f9add4a09bd789cc577beb6b87465a.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">ABCD
0123456789
ABCD0123456789
ABCD456789
ABCD45ABC9</code></pre>
						</div>

						<br/>
						<h3>배열의 활용</h3>
						<p>
							배열을 어떻게 활용하는지 예제를 통해서 배워보겠습니다. 다음의 예제들를 직접 코딩하고 실행해보세요.
						</p>
						<ul>
							<li>총합과 평균 구하기</li>
							<li>최대값과 최소값 구하기</li>
							<li>배열의 요소 순서 바꾸기 (로또번호 생성)</li>
							<li>정렬하기 (오름차순, 내림차순)</li>
							<li>빈도수 구하기 (배열에 어떤 값이 몇 개 저장되어 있는지 세어보기)</li>
						</ul>
						<h5>배열의 활용 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/1fee89cbd0cecb62478381da114d9133.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
					</section><!--//section-->
					
					<section class="docs-section" id="item-6-2">
						<h2 class="section-heading">String 배열</h2>
						<p></p>

						<h3>String배열의 선언과 생성</h3>
						<p>
							배열의 타입이 <code>String</code>인 경우 <code>int</code>배열의 선언과 다르지 않습니다.
						</p>
						<h5>문자열을 담을 수 있는 배열을 생성 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">String[] name=new String[3]; //3개의 문자열을 담을 수 있는 배열을 생성</code></pre>
						</div>
						<p>
							3개의 String 타입의 참조변수를 저장하기 위한 공간이 마련되고 참조형 변수의 기본값은 null이므로 각 요소의 값은 null로 초기화됩니다.
						</p>

						<h5>변수타입에 따른 기본값 : </h5>
						<div class="table-responsive my-4">
							<table class="table table-bordered table-dark">
								<thead>
								<tr>
									<th scope="col">#</th>
									<th scope="col">자료형</th>
									<th scope="col">기본값</th>
								</tr>
								</thead>
								<tbody>
								<tr>
									<th scope="row">1</th>
									<td>boolean</td>
									<td>false</td>
								</tr>
								<tr>
									<th scope="row">2</th>
									<td>char</td>
									<td>'\u0000'</td>
								</tr>
								<tr>
									<th scope="row">3</th>
									<td>byte, short, int</td>
									<td>0</td>
								</tr>
								<tr>
									<th scope="row">4</th>
									<td>long</td>
									<td>0L</td>
								</tr>
								<tr>
									<th scope="row">5</th>
									<td>float</td>
									<td>0.0f</td>
								</tr>
								<tr>
									<th scope="row">6</th>
									<td>double</td>
									<td>0.0d 또는 0.0</td>
								</tr>
								<tr class="table-success">
									<th scope="row">7</th>
									<td>참조형 변수</td>
									<td>null</td>
								</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->

						<br/>
						<h3>String 배열의 초기화</h3>
						<p>
							초기화 역시 int배열과 동일한 방법으로 합니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">String[] name = new String[3]; // 길이가 3인 String 배열을 생성
name[0]="Kim";
name[2]="Lee";
name[1]="Park";</code></pre>
						</div>

						<p>
							또는 괄호 {}를 사용해서 다음과 같이 간단히 초기화 할 수도 있습니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">String[] name = new String[]{"Kim", "Lee", "Park"};
String[] name = {"Kim", "Lee", "Park"};</code></pre>
						</div>

						<br/>
						<h3>char 배열과 String 클래스</h3>
						<p>
							문자열이라는 용어는 문자를 연이어 늘어놓은 것을 의미하므로 char배열과 같은 뜻입니다.<br/>
							그런데 자바에서는 char 배열이 아닌 String 클래스를 이용해서 문자열을 처리하는 이유는 String 클래스가 char 배열에 여러 가지 기능을 추가하여 확장한 것이기 때문입니다.<br/>
							char 배열을 사용하는 것보다 String 클래스를 사용하는 것이 문자열을 다루기 편리합니다.
						</p>
						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
	                                <span class="callout-icon-holder me-1">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
									Note
								</h4>
								<p>* String 클래스는 char 배열에 기능(메서드)를 추가한 것이다.</p>
							</div><!--//content-->
						</div><!--//callout-block-->

						<p>char 배열과 String 클래스의 한 가지 중요한 차이가 있는데, String 객체는 읽을 수만 있을 뿐 내용을 변경할 수 없다는 것입니다.</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">String str = "java";
str = str + 8;           // "java8"이라는 새로운 문자열이 str에 저장된다.
System.out.println(str); // "java8"</code></pre>
						</div>
						<p>문자열 str의 내용이 변경되는 것 같지만, 문자열은 변경할 수 없으므로 새로운 내용의 문자열이 생성됩니다.</p>

						<h3>String클래스의 주요 메서드 : </h3>
						<div class="table-responsive my-4">
							<table class="table table-striped">
								<thead>
									<tr>
										<th scope="col">#</th>
										<th scope="col">메서드</th>
										<th scope="col">설명</th>
									</tr>
								</thead>
								<tbody>
									<tr>
										<th scope="row">1</th>
										<td>char charAt(int index)</td>
										<td>문자열에서 해당 위치(index)에 있는 문자를 반환합니다.</td>
									</tr>
									<tr>
										<th scope="row">2</th>
										<td>int lenght()</td>
										<td>문자열의 길이를 반환합니다.</td>
									</tr>
									<tr>
										<th scope="row">3</th>
										<td>String substring(int from, int to)</td>
										<td>문자열에서 해당 범위(from - to)에 있는 문자열을 반환합니다. (to는 범위에 포함되지 않습니다.)</td>
									</tr>
									<tr>
										<th scope="row">4</th>
										<td>boolean equals(String str)</td>
										<td>문자열의 내용이 같은지 확인합니다. 같으면 결과는 true, 다르면 false가 됩니다.</td>
									</tr>
									<tr>
										<th scope="row">5</th>
										<td>char[] toCharArray()</td>
										<td>문자열을 문자배열(char[])로 변환해서 반환합니다.</td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->

						<br/>
						<h3>char배열과 String 클래스의 변환</h3>
						<p>
							가끔 char배열을 String 클래스로 변환하거나, 또는 그 반대로 변환해야하는 경우가 있습니다. 다음 코드를 참고하세요.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">char[] chArr = {'A','B','C'};
String str = new String(chArr); // char배열 -> String
char[] tmp = str.toCharArray(); // String -> char배열</code></pre>
						</div>
					</section><!--//section-->
					
					<section class="docs-section" id="item-6-3">
						<h2 class="section-heading">다차원 배열</h2>
						<p>
							우리가 배운 배열은 1차원 배열인데, 2차원 이상의 배열, 즉 다차원 배열(multi-dimensional)도 선언해서 사용할 수 있습니다.
							메모리 용량이 허용하는 한 차원의 제한이 없는 다차원 배열을 생성할 수 있습니다.
						</p>

						<br/>
						<h3>2차원 배열의 선언</h3>
						<p>
							2차원 배열을 선언하는 방법은 1차원 배열과 같습니다. 다만 괄호([])가 하나 더 들어갈 뿐입니다.
						</p>
						<h5>Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">타입[][] 변수이름; // int[][] score;
타입 변수이름[][]; // int score[][];
타입[] 변수이름[]; // int[] score[];</code></pre>
						</div>

						<br/>
						<h3>2차원 배열의 INDEX</h3>
						<p>
							2차원 배열은 행(row)와 열(column)로 구성되어 있기 때문에 <strong>index도 행과 열에 각각 하나씩 존재</strong>합니다. 행index의 범위는 0 ~ 행의 길이 -1 이고, 열index의 범위는 0 ~ 열의 길이 -1입니다.
							그리고 2차원 배열의 각 요소에 접근하는 방법은 <code>배열이름[행index][열index]</code>입니다.
						</p>
						<h5>2차원 배열의 index로 접근 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[][] score = new int[4][3];
System.out.println(score[0][0]);    // 2차원 배열 score의 1행 1열의 값을 출력합니다.</code></pre>
						</div>

						<br/>
						<h3>2차원 배열의 초기화</h3>
						<p>
							2차원 배열도 1차원 배열과 마찬가지로 괄호{}를 사용해서 생성과 초기화를 동시에 할 수 있습니다. 다만 1차원 배열보다 괄호{}를 한번 더 써서 행별로 구별합니다.
						</p>

						<h5>2차원 배열의 초기화 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">int[][] arr = new int[][] {{1, 2, 3}, {4, 5, 6}};
int[][] arr = {{1, 2, 3}, {4, 5, 6}};    // new int[][] 를 생략할 수 있습니다.

// 가독성을 높이기 위해서 행열로 줄 바꿈을 해주는 것도 좋습니다.
int[][] arr = {
	{1, 2, 3},
	{4, 5, 6}
};</code></pre>
						</div>
						<p>
							2차원 배열의 길이는 어떻게 될까? 우리는 배열의 길이를 얻어오기 위해서 <code>배열이름.length</code>를 사용했습니다.
							2차원 배열도 1차원 배열처럼 <code>배열이름.length</code>를 사용합니다. 단지 2차원 배열은 배열의 배열로 구성되어 있으므로 2차원 배열의 1차 배열은 <code>배열이름.length</code>으로 가져오고 2차 배열은 <code>배열이름[index].length</code>로 가져올 수 있습니다.
						</p>
						<h5>2차원 배열 Example : </h5>
						<div class="docs-code-block">
							<!-- ** Embed github code starts ** -->
							<script src="https://gist.github.com/yk1983/ee86df583485e1904f336d557744e9ab.js"></script>
							<!-- ** Embed github code ends ** -->
						</div><!--//docs-code-block-->
						<h5>Result : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">score[0][0]=100
score[0][1]=100
score[0][2]=100
score[1][0]=20
score[1][1]=20
score[1][2]=20
score[2][0]=30
score[2][1]=30
score[2][2]=30
score[3][0]=40
score[3][1]=40
score[3][2]=40
sum=570</code></pre>
						</div>

						<br/>
						<h3>가변 배열 (Dynamic Array)</h3>
						<p>
							자바에서는 2차원 배열을 생성할 때 열의 길이를 명시하지 않음으로써, 행마다 다른 길이의 배열을 요소로 저장할 수 있습니다. 이렇게 <strong>행마다 다른 길이의 배열을 저장할 수 있는 배열</strong>을 <strong>가변 배열(dynamic array)</strong>이라고 합니다.<br/>
							배열을 생성할 때 두 번째 첨자를 생략하면 가변 배열을 만들 수 있습니다. 또한, 가변 배열도 초기화 블록을 사용하여 배열을 선언과 동시에 초기화할 수 있습니다.
						</p>
						<h5>가변 배열 Example : </h5>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">// 두 번째 차원의 길이는 지정하지 않습니다.
int[][] score = new int[5][];
score[0] = new int[4];
score[0] = new int[3];
score[0] = new int[2];
score[0] = new int[2];
score[0] = new int[3];

// 배열을 선언과 동시에 초기화
int[][] score = {
    {10, 20, 30, 40},
    {10, 20, 30},
    {10, 20},
    {30, 40},
    {50, 60, 70}
};</code></pre>
						</div>
					</section><!--//section-->
			    </article><!--//docs-article-->
			    
			    <article class="docs-article" id="section-7">
				    <header class="docs-header">
					    <h1 class="docs-heading">객체지향 프로그래밍 I</h1>
					    <section class="docs-intro">
						    <p>// TODO</p>
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="item-7-1">
						<h2 class="section-heading">객체지향언어</h2>
						<p>// TODO</p>
					</section><!--//section-->
					
					<section class="docs-section" id="item-7-2">
						<h2 class="section-heading">클래스와 객체</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-7-3">
						<h2 class="section-heading">변수와 메서드</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-7-4">
						<h2 class="section-heading">오버로딩(overloading)</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-7-5">
						<h2 class="section-heading">생성자(constructor)</h2>
						<p>// TODO</p>
					</section><!--//section-->
			    </article><!--//docs-article-->

				<article class="docs-article" id="section-8">
					<header class="docs-header">
						<h1 class="docs-heading">객체지향 프로그래밍 II</h1>
						<section class="docs-intro">
							<p>// TODO</p>
						</section><!--//docs-intro-->
					</header>
					<section class="docs-section" id="item-8-1">
						<h2 class="section-heading">상속(inheritance)</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-8-2">
						<h2 class="section-heading">오버라이딩(overriding)</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-8-3">
						<h2 class="section-heading">package와 import</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-8-4">
						<h2 class="section-heading">제어자(modifier)</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-8-5">
						<h2 class="section-heading">다형성(polymorphism)</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-8-6">
						<h2 class="section-heading">추상클래스(abstract class)</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-8-7">
						<h2 class="section-heading">인터페이스(interface)</h2>
						<p>// TODO</p>
					</section><!--//section-->
				</article><!--//docs-article-->

				<article class="docs-article" id="section-9">
					<header class="docs-header">
						<h1 class="docs-heading">예외처리</h1>
						<section class="docs-intro">
							<p>// TODO</p>
						</section><!--//docs-intro-->
					</header>
					<section class="docs-section" id="item-9-1">
						<h2 class="section-heading">예외처리</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-9-2">
						<h2 class="section-heading">try-catch</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-9-3">
						<h2 class="section-heading">finally블럭</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-9-4">
						<h2 class="section-heading">예외 되던지기</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-9-5">
						<h2 class="section-heading">사용자정의 예외</h2>
						<p>// TODO</p>
					</section><!--//section-->
				</article><!--//docs-article-->

				<article class="docs-article" id="section-10">
					<header class="docs-header">
						<h1 class="docs-heading">java.lang패키지</h1>
						<section class="docs-intro">
							<p>// TODO</p>
						</section><!--//docs-intro-->
					</header>
					<section class="docs-section" id="item-10-1">
						<h2 class="section-heading">Object클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-10-2">
						<h2 class="section-heading">String클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-10-3">
						<h2 class="section-heading">StringBuffer클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-10-4">
						<h2 class="section-heading">Math클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-10-5">
						<h2 class="section-heading">wrapper클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->
				</article><!--//docs-article-->

				<article class="docs-article" id="section-11">
					<header class="docs-header">
						<h1 class="docs-heading">내부 클래스</h1>
						<section class="docs-intro">
							<p>// TODO</p>
						</section><!--//docs-intro-->
					</header>
					<section class="docs-section" id="item-11-1">
						<h2 class="section-heading">내부 클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-11-2">
						<h2 class="section-heading">익명 클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->
				</article><!--//docs-article-->

				<article class="docs-article" id="section-12">
					<header class="docs-header">
						<h1 class="docs-heading">컬렉션 프레임웍</h1>
						<section class="docs-intro">
							<p>// TODO</p>
						</section><!--//docs-intro-->
					</header>
					<section class="docs-section" id="item-12-1">
						<h2 class="section-heading">컬렉션 프레임웍</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-12-2">
						<h2 class="section-heading">유용한 클래스</h2>
						<p>// TODO</p>
					</section><!--//section-->
				</article><!--//docs-article-->

				<article class="docs-article" id="section-13">
					<header class="docs-header">
						<h1 class="docs-heading">쓰레드</h1>
						<section class="docs-intro">
							<p>// TODO</p>
						</section><!--//docs-intro-->
					</header>
				</article><!--//docs-article-->

				<article class="docs-article" id="section-14">
					<header class="docs-header">
						<h1 class="docs-heading">입출력(I/O)</h1>
						<section class="docs-intro">
							<p>// TODO</p>
						</section><!--//docs-intro-->
					</header>
					<section class="docs-section" id="item-14-1">
						<h2 class="section-heading">입출력</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-14-2">
						<h2 class="section-heading">바이트기반 스트림</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-14-3">
						<h2 class="section-heading">바이트기반의 보조스트림</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-14-4">
						<h2 class="section-heading">문자기반 스트림</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-14-5">
						<h2 class="section-heading">문자기반의 보조스트림</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-14-6">
						<h2 class="section-heading">File</h2>
						<p>// TODO</p>
					</section><!--//section-->

					<section class="docs-section" id="item-14-7">
						<h2 class="section-heading">직렬화(Serialization)</h2>
						<p>// TODO</p>
					</section><!--//section-->
				</article><!--//docs-article-->

			    <article class="docs-article" id="section-15">
				    <header class="docs-header">
					    <h1 class="docs-heading">FAQs</h1>
					    <section class="docs-intro">
						    <p>Section intro goes here. You can list all your FAQs using the format below.</p>
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="item-15-1">
						<h2 class="section-heading">FAQ <small>(용어정리)</small></h2>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>What's sit amet quam eget lacinia?</h5>
						<p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium.</p>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>How to ipsum dolor sit amet quam tortor?</h5>
						<p>Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. </p>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>Can I  bibendum sodales?</h5>
						<p>Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. </p>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>Where arcu sed urna gravida?</h5>
						<p>Aenean et sodales nisi, vel efficitur sapien. Quisque molestie diam libero, et elementum diam mollis ac. In dignissim aliquam est eget ullamcorper. Sed id sodales tortor, eu finibus leo. Vivamus dapibus sollicitudin justo vel fermentum. Curabitur nec arcu sed urna gravida lobortis. Donec lectus est, imperdiet eu viverra viverra, ultricies nec urna. </p>
					</section><!--//section-->
					
					<section class="docs-section" id="item-15-2">
						<h2 class="section-heading">FAQ <small>(질문)</small></h2>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>What's sit amet quam eget lacinia?</h5>
						<p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium.</p>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>How to ipsum dolor sit amet quam tortor?</h5>
						<p>Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. </p>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>Can I  bibendum sodales?</h5>
						<p>Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. </p>
						<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>Where arcu sed urna gravida?</h5>
						<p>Aenean et sodales nisi, vel efficitur sapien. Quisque molestie diam libero, et elementum diam mollis ac. In dignissim aliquam est eget ullamcorper. Sed id sodales tortor, eu finibus leo. Vivamus dapibus sollicitudin justo vel fermentum. Curabitur nec arcu sed urna gravida lobortis. Donec lectus est, imperdiet eu viverra viverra, ultricies nec urna. </p>
					</section><!--//section-->
					
					<section class="docs-section" id="item-15-3">
							<h2 class="section-heading">FAQ <small>(Tip)</small></h2>
						    <h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>How to dapibus sollicitudin justo vel fermentum?</h5>
							<p>Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. </p>
							<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>How long bibendum sodales?</h5>
							<p>Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. </p>
							<h5 class="pt-3"><i class="fas fa-question-circle me-1"></i>Where dapibus sollicitudin?</h5>
							<p>Aenean et sodales nisi, vel efficitur sapien. Quisque molestie diam libero, et elementum diam mollis ac. In dignissim aliquam est eget ullamcorper. Sed id sodales tortor, eu finibus leo. Vivamus dapibus sollicitudin justo vel fermentum. Curabitur nec arcu sed urna gravida lobortis. Donec lectus est, imperdiet eu viverra viverra, ultricies nec urna. </p>
					</section><!--//section-->
			    </article><!--//docs-article-->

			    <footer class="footer">
				    <div class="container text-center py-5">
				        <small class="copyright">Template Copyright &copy; <a href="https://themes.3rdwavemedia.com/" target="_blank">3rd Wave Media</a></small>
				        <ul class="social-list list-unstyled pt-4 mb-0">
						    <li class="list-inline-item"><a href="#"><i class="fab fa-github fa-fw"></i></a></li> 
				            <li class="list-inline-item"><a href="#"><i class="fab fa-twitter fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-slack fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-product-hunt fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-facebook-f fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-instagram fa-fw"></i></a></li>
				        </ul><!--//social-list-->
				    </div>
			    </footer>
		    </div> 
	    </div>
    </div><!--//docs-wrapper-->
   
       
    <!-- Javascript -->          
    <script src="../assets/plugins/popper.min.js"></script>
    <script src="../assets/plugins/bootstrap/js/bootstrap.min.js"></script>  
    
    
    <!-- Page Specific JS -->
    <script src="../assets/plugins/smoothscroll.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="../assets/js/highlight-custom.js"></script> 
    <script src="../assets/plugins/simplelightbox/simple-lightbox.min.js"></script>      
    <script src="../assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script> 
    <script src="../assets/js/docs.js"></script> 

</body>
</html> 

